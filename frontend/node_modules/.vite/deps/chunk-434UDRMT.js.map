{
  "version": 3,
  "sources": ["../../.pnpm/@tanstack+devtools@0.3.0_csstype@3.1.3_solid-js@1.9.9/node_modules/@tanstack/devtools/src/constants.ts", "../../.pnpm/@tanstack+devtools@0.3.0_csstype@3.1.3_solid-js@1.9.9/node_modules/@tanstack/devtools/src/utils/storage.ts", "../../.pnpm/@tanstack+devtools@0.3.0_csstype@3.1.3_solid-js@1.9.9/node_modules/@tanstack/devtools/src/context/devtools-store.ts", "../../.pnpm/solid-js@1.9.9/node_modules/solid-js/store/dist/dev.js", "../../.pnpm/@tanstack+devtools@0.3.0_csstype@3.1.3_solid-js@1.9.9/node_modules/@tanstack/devtools/src/utils/sanitize.ts", "../../.pnpm/@tanstack+devtools@0.3.0_csstype@3.1.3_solid-js@1.9.9/node_modules/@tanstack/devtools/src/context/devtools-context.tsx"],
  "sourcesContent": ["export const PLUGIN_CONTAINER_ID = 'plugin-container'\nexport const PLUGIN_TITLE_CONTAINER_ID = 'plugin-title-container'\n", "export const getStorageItem = (key: string) => localStorage.getItem(key)\nexport const setStorageItem = (key: string, value: string) => {\n  try {\n    localStorage.setItem(key, value)\n  } catch (_e) {\n    return\n  }\n}\n\nexport const TANSTACK_DEVTOOLS = 'tanstack_devtools'\nexport const TANSTACK_DEVTOOLS_STATE = 'tanstack_devtools_state'\nexport const TANSTACK_DEVTOOLS_SETTINGS = 'tanstack_devtools_settings'\n", "import type { TabName } from '../tabs'\nimport type { TanStackDevtoolsPlugin } from './devtools-context'\n\ntype ModifierKey = 'Alt' | 'Control' | 'Meta' | 'Shift'\ntype KeyboardKey = ModifierKey | (string & {})\n\ntype TriggerPosition =\n  | 'top-left'\n  | 'top-right'\n  | 'bottom-left'\n  | 'bottom-right'\n  | 'middle-left'\n  | 'middle-right'\n\nexport type DevtoolsStore = {\n  settings: {\n    /**\n     * Whether the dev tools should be open by default\n     * @default false\n     */\n    defaultOpen: boolean\n    /**\n     * Whether the dev tools trigger should be hidden until the user hovers over it\n     * @default false\n     */\n    hideUntilHover: boolean\n    /**\n     * The position of the trigger button\n     * @default \"bottom-right\"\n     */\n    position: TriggerPosition\n\n    /**\n     * The location of the panel once it is open\n     * @default \"bottom\"\n     */\n    panelLocation: 'top' | 'bottom'\n    /**\n     * The hotkey to open the dev tools\n     * @default \"shift+a\"\n     */\n    openHotkey: Array<KeyboardKey>\n    /**\n     * Whether to require the URL flag to open the dev tools\n     * @default false\n     */\n    requireUrlFlag: boolean\n    /**\n     * The URL flag to open the dev tools, used in conjunction with requireUrlFlag (if set to true)\n     * @default \"tanstack-devtools\"\n     */\n    urlFlag: string\n  }\n  state: {\n    activeTab: TabName\n    height: number\n    activePlugin?: string | undefined\n    persistOpen: boolean\n  }\n  plugins?: Array<TanStackDevtoolsPlugin>\n}\n\nexport const initialState: DevtoolsStore = {\n  settings: {\n    defaultOpen: false,\n    hideUntilHover: false,\n    position: 'bottom-right',\n    panelLocation: 'bottom',\n    openHotkey: ['Shift', 'A'],\n    requireUrlFlag: false,\n    urlFlag: 'tanstack-devtools',\n  },\n  state: {\n    activeTab: 'plugins',\n    height: 400,\n    activePlugin: undefined,\n    persistOpen: false,\n  },\n}\n", "import { DEV as DEV$1, $PROXY, $TRACK, getListener, batch, createSignal } from 'solid-js';\n\nconst $RAW = Symbol(\"store-raw\"),\n  $NODE = Symbol(\"store-node\"),\n  $HAS = Symbol(\"store-has\"),\n  $SELF = Symbol(\"store-self\");\nconst DevHooks = {\n  onStoreNodeUpdate: null\n};\nfunction wrap$1(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps$1)\n    });\n    if (!Array.isArray(value)) {\n      const keys = Object.keys(value),\n        desc = Object.getOwnPropertyDescriptors(value);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const prop = keys[i];\n        if (desc[prop].get) {\n          Object.defineProperty(value, prop, {\n            enumerable: desc[prop].enumerable,\n            get: desc[prop].get.bind(p)\n          });\n        }\n      }\n    }\n  }\n  return p;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW]) return result;\n  if (!isWrappable(item) || set.has(item)) return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item)) item = item.slice(0);else set.add(item);\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v, set)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item)) item = Object.assign({}, item);else set.add(item);\n    const keys = Object.keys(item),\n      desc = Object.getOwnPropertyDescriptors(item);\n    for (let i = 0, l = keys.length; i < l; i++) {\n      prop = keys[i];\n      if (desc[prop].get) continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v) item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getNodes(target, symbol) {\n  let nodes = target[symbol];\n  if (!nodes) Object.defineProperty(target, symbol, {\n    value: nodes = Object.create(null)\n  });\n  return nodes;\n}\nfunction getNode(nodes, property, value) {\n  if (nodes[property]) return nodes[property];\n  const [s, set] = createSignal(value, {\n    equals: false,\n    internal: true\n  });\n  s.$ = set;\n  return nodes[property] = s;\n}\nfunction proxyDescriptor$1(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  getListener() && getNode(getNodes(target, $NODE), $SELF)();\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  has(target, property) {\n    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === \"__proto__\") return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set() {\n    console.warn(\"Cannot mutate a Store directly\");\n    return true;\n  },\n  deleteProperty() {\n    console.warn(\"Cannot mutate a Store directly\");\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor$1\n};\nfunction setProperty(state, property, value, deleting = false) {\n  if (!deleting && state[property] === value) return;\n  const prev = state[property],\n    len = state.length;\n  DevHooks.onStoreNodeUpdate && DevHooks.onStoreNodeUpdate(state, property, value, prev);\n  if (value === undefined) {\n    delete state[property];\n    if (state[$HAS] && state[$HAS][property] && prev !== undefined) state[$HAS][property].$();\n  } else {\n    state[property] = value;\n    if (state[$HAS] && state[$HAS][property] && prev === undefined) state[$HAS][property].$();\n  }\n  let nodes = getNodes(state, $NODE),\n    node;\n  if (node = getNode(nodes, property, prev)) node.$(() => value);\n  if (Array.isArray(state) && state.length !== len) {\n    for (let i = state.length; i < len; i++) (node = nodes[i]) && node.$();\n    (node = getNode(nodes, \"length\", len)) && node.$(state.length);\n  }\n  (node = nodes[$SELF]) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\") next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next) return;\n    let i = 0,\n      len = next.length;\n    for (; i < len; i++) {\n      const value = next[i];\n      if (current[i] !== value) setProperty(current, i, value);\n    }\n    setProperty(current, \"length\", len);\n  } else mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part,\n    prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part,\n      isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i = 0; i < part.length; i++) {\n        updatePath(current, [part[i]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i = 0; i < current.length; i++) {\n        if (part(current[i], i)) updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const {\n        from = 0,\n        to = current.length - 1,\n        by = 1\n      } = part;\n      for (let i = from; i <= to; i += by) {\n        updatePath(current, [i].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev) return;\n  }\n  if (part === undefined && value == undefined) return;\n  value = unwrap(value);\n  if (part === undefined || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {\n    mergeStoreNode(prev, value);\n  } else setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  if (typeof unwrappedStore !== \"object\" && typeof unwrappedStore !== \"function\") throw new Error(`Unexpected type ${typeof unwrappedStore} received when initializing 'createStore'. Expected an object.`);\n  const wrappedStore = wrap$1(unwrappedStore);\n  DEV$1.registerGraph({\n    value: unwrappedStore,\n    name: options && options.name\n  });\n  function setStore(...args) {\n    batch(() => {\n      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\n\nfunction proxyDescriptor(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || desc.set || !desc.configurable || property === $PROXY || property === $NODE) return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  desc.set = v => target[$PROXY][property] = v;\n  return desc;\n}\nconst proxyTraps = {\n  get(target, property, receiver) {\n    if (property === $RAW) return target;\n    if (property === $PROXY) return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getNodes(target, $NODE);\n    const tracked = nodes[property];\n    let value = tracked ? tracked() : target[property];\n    if (property === $NODE || property === $HAS || property === \"__proto__\") return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      const isFunction = typeof value === \"function\";\n      if (getListener() && (!isFunction || target.hasOwnProperty(property)) && !(desc && desc.get)) value = getNode(nodes, property, value)();else if (value != null && isFunction && value === Array.prototype[property]) {\n        return (...args) => batch(() => Array.prototype[property].apply(receiver, args));\n      }\n    }\n    return isWrappable(value) ? wrap(value) : value;\n  },\n  has(target, property) {\n    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === $HAS || property === \"__proto__\") return true;\n    getListener() && getNode(getNodes(target, $HAS), property)();\n    return property in target;\n  },\n  set(target, property, value) {\n    batch(() => setProperty(target, property, unwrap(value)));\n    return true;\n  },\n  deleteProperty(target, property) {\n    batch(() => setProperty(target, property, undefined, true));\n    return true;\n  },\n  ownKeys: ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor\n};\nfunction wrap(value) {\n  let p = value[$PROXY];\n  if (!p) {\n    Object.defineProperty(value, $PROXY, {\n      value: p = new Proxy(value, proxyTraps)\n    });\n    const keys = Object.keys(value),\n      desc = Object.getOwnPropertyDescriptors(value);\n    const proto = Object.getPrototypeOf(value);\n    const isClass = proto !== null && value !== null && typeof value === \"object\" && !Array.isArray(value) && proto !== Object.prototype;\n    if (isClass) {\n      let curProto = proto;\n      while (curProto != null) {\n        const descriptors = Object.getOwnPropertyDescriptors(curProto);\n        keys.push(...Object.keys(descriptors));\n        Object.assign(desc, descriptors);\n        curProto = Object.getPrototypeOf(curProto);\n      }\n    }\n    for (let i = 0, l = keys.length; i < l; i++) {\n      const prop = keys[i];\n      if (isClass && prop === \"constructor\") continue;\n      if (desc[prop].get) {\n        const get = desc[prop].get.bind(p);\n        Object.defineProperty(value, prop, {\n          get,\n          configurable: true\n        });\n      }\n      if (desc[prop].set) {\n        const og = desc[prop].set,\n          set = v => batch(() => og.call(p, v));\n        Object.defineProperty(value, prop, {\n          set,\n          configurable: true\n        });\n      }\n    }\n  }\n  return p;\n}\nfunction createMutable(state, options) {\n  const unwrappedStore = unwrap(state || {});\n  if (typeof unwrappedStore !== \"object\" && typeof unwrappedStore !== \"function\") throw new Error(`Unexpected type ${typeof unwrappedStore} received when initializing 'createMutable'. Expected an object.`);\n  const wrappedStore = wrap(unwrappedStore);\n  DEV$1.registerGraph({\n    value: unwrappedStore,\n    name: options && options.name\n  });\n  return wrappedStore;\n}\nfunction modifyMutable(state, modifier) {\n  batch(() => modifier(unwrap(state)));\n}\n\nconst $ROOT = Symbol(\"store-root\");\nfunction applyState(target, parent, property, merge, key) {\n  const previous = parent[property];\n  if (target === previous) return;\n  const isArray = Array.isArray(target);\n  if (property !== $ROOT && (!isWrappable(target) || !isWrappable(previous) || isArray !== Array.isArray(previous) || key && target[key] !== previous[key])) {\n    setProperty(parent, property, target);\n    return;\n  }\n  if (isArray) {\n    if (target.length && previous.length && (!merge || key && target[0] && target[0][key] != null)) {\n      let i, j, start, end, newEnd, item, newIndicesNext, keyVal;\n      for (start = 0, end = Math.min(previous.length, target.length); start < end && (previous[start] === target[start] || key && previous[start] && target[start] && previous[start][key] && previous[start][key] === target[start][key]); start++) {\n        applyState(target[start], previous, start, merge, key);\n      }\n      const temp = new Array(target.length),\n        newIndices = new Map();\n      for (end = previous.length - 1, newEnd = target.length - 1; end >= start && newEnd >= start && (previous[end] === target[newEnd] || key && previous[end] && target[newEnd] && previous[end][key] && previous[end][key] === target[newEnd][key]); end--, newEnd--) {\n        temp[newEnd] = previous[end];\n      }\n      if (start > newEnd || start > end) {\n        for (j = start; j <= newEnd; j++) setProperty(previous, j, target[j]);\n        for (; j < target.length; j++) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        }\n        if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n        return;\n      }\n      newIndicesNext = new Array(newEnd + 1);\n      for (j = newEnd; j >= start; j--) {\n        item = target[j];\n        keyVal = key && item ? item[key] : item;\n        i = newIndices.get(keyVal);\n        newIndicesNext[j] = i === undefined ? -1 : i;\n        newIndices.set(keyVal, j);\n      }\n      for (i = start; i <= end; i++) {\n        item = previous[i];\n        keyVal = key && item ? item[key] : item;\n        j = newIndices.get(keyVal);\n        if (j !== undefined && j !== -1) {\n          temp[j] = previous[i];\n          j = newIndicesNext[j];\n          newIndices.set(keyVal, j);\n        }\n      }\n      for (j = start; j < target.length; j++) {\n        if (j in temp) {\n          setProperty(previous, j, temp[j]);\n          applyState(target[j], previous, j, merge, key);\n        } else setProperty(previous, j, target[j]);\n      }\n    } else {\n      for (let i = 0, len = target.length; i < len; i++) {\n        applyState(target[i], previous, i, merge, key);\n      }\n    }\n    if (previous.length > target.length) setProperty(previous, \"length\", target.length);\n    return;\n  }\n  const targetKeys = Object.keys(target);\n  for (let i = 0, len = targetKeys.length; i < len; i++) {\n    applyState(target[targetKeys[i]], previous, targetKeys[i], merge, key);\n  }\n  const previousKeys = Object.keys(previous);\n  for (let i = 0, len = previousKeys.length; i < len; i++) {\n    if (target[previousKeys[i]] === undefined) setProperty(previous, previousKeys[i], undefined);\n  }\n}\nfunction reconcile(value, options = {}) {\n  const {\n      merge,\n      key = \"id\"\n    } = options,\n    v = unwrap(value);\n  return state => {\n    if (!isWrappable(state) || !isWrappable(v)) return v;\n    const res = applyState(v, {\n      [$ROOT]: state\n    }, $ROOT, merge, key);\n    return res === undefined ? state : res;\n  };\n}\nconst producers = new WeakMap();\nconst setterTraps = {\n  get(target, property) {\n    if (property === $RAW) return target;\n    const value = target[property];\n    let proxy;\n    return isWrappable(value) ? producers.get(value) || (producers.set(value, proxy = new Proxy(value, setterTraps)), proxy) : value;\n  },\n  set(target, property, value) {\n    setProperty(target, property, unwrap(value));\n    return true;\n  },\n  deleteProperty(target, property) {\n    setProperty(target, property, undefined, true);\n    return true;\n  }\n};\nfunction produce(fn) {\n  return state => {\n    if (isWrappable(state)) {\n      let proxy;\n      if (!(proxy = producers.get(state))) {\n        producers.set(state, proxy = new Proxy(state, setterTraps));\n      }\n      fn(proxy);\n    }\n    return state;\n  };\n}\n\nconst DEV = {\n  $NODE,\n  isWrappable,\n  hooks: DevHooks\n} ;\n\nexport { $RAW, DEV, createMutable, createStore, modifyMutable, produce, reconcile, unwrap };\n", "export const tryParseJson = <T>(json: string | null): T | undefined => {\n  if (!json) return undefined\n  try {\n    return JSON.parse(json)\n  } catch (_e) {\n    return undefined\n  }\n}\n\nexport const uppercaseFirstLetter = (value: string) =>\n  value.charAt(0).toUpperCase() + value.slice(1)\n", "import { createContext } from 'solid-js'\nimport { createStore } from 'solid-js/store'\nimport { tryParseJson } from '../utils/sanitize'\nimport {\n  TANSTACK_DEVTOOLS_SETTINGS,\n  TANSTACK_DEVTOOLS_STATE,\n  getStorageItem,\n  setStorageItem,\n} from '../utils/storage'\nimport { initialState } from './devtools-store'\nimport type { DevtoolsStore } from './devtools-store'\nimport type { JSX, Setter } from 'solid-js'\n\nexport interface TanStackDevtoolsPlugin {\n  /**\n   * Name to be displayed in the devtools UI.\n   * If a string, it will be used as the plugin name.\n   * If a function, it will be called with the mount element.\n   *\n   * Example:\n   * ```ts\n   *   {\n   *     // If a string, it will be used as the plugin name\n   *     name: \"Your Plugin\",\n   *     render: () => {}\n   *   }\n   * ```\n   * or\n   *\n   * ```ts\n   *   {\n   *     // If a function, it will be called with the mount element\n   *     name: (el) => {\n   *       el.innerText = \"Your Plugin Name\"\n   *       // Your name logic here\n   *     },\n   *     render: () => {}\n   *   }\n   * ```\n   */\n  name: string | ((el: HTMLHeadingElement) => void)\n  /**\n   * Unique identifier for the plugin.\n   * If not provided, it will be generated based on the name.\n   */\n  id?: string\n  /**\n   * Render the plugin UI by using the provided element. This function will be called\n   * when the plugin tab is clicked and expected to be mounted.\n   * @param el The mount element for the plugin.\n   * @returns void\n   *\n   * Example:\n   * ```ts\n   *   render: (el) => {\n   *     el.innerHTML = \"<h1>Your Plugin</h1>\"\n   *   }\n   * ```\n   */\n  render: (el: HTMLDivElement) => void\n}\nexport const DevtoolsContext = createContext<{\n  store: DevtoolsStore\n  setStore: Setter<DevtoolsStore>\n}>()\n\ninterface ContextProps {\n  children: JSX.Element\n  plugins?: Array<TanStackDevtoolsPlugin>\n  config?: TanStackDevtoolsConfig\n}\n\nconst getSettings = () => {\n  const settingsString = getStorageItem(TANSTACK_DEVTOOLS_SETTINGS)\n  const settings = tryParseJson<DevtoolsStore['settings']>(settingsString)\n  return {\n    ...settings,\n  }\n}\n\nconst generatePluginId = (plugin: TanStackDevtoolsPlugin, index: number) => {\n  // if set by user, return the plugin id\n  if (plugin.id) {\n    return plugin.id\n  }\n  if (typeof plugin.name === 'string') {\n    // if name is a string, use it to generate an id\n    return plugin.name.toLowerCase().replace(' ', '-')\n  }\n  // Name is JSX? return the index as a string\n  return index.toString()\n}\n\nconst getExistingStateFromStorage = (\n  config?: TanStackDevtoolsConfig,\n  plugins?: Array<TanStackDevtoolsPlugin>,\n) => {\n  const existingState = getStorageItem(TANSTACK_DEVTOOLS_STATE)\n  const settings = getSettings()\n\n  const state: DevtoolsStore = {\n    ...initialState,\n    plugins:\n      plugins?.map((plugin, i) => {\n        const id = generatePluginId(plugin, i)\n        return {\n          ...plugin,\n          id,\n        }\n      }) || [],\n    state: {\n      ...initialState.state,\n      ...(existingState ? JSON.parse(existingState) : {}),\n    },\n    settings: {\n      ...initialState.settings,\n      ...config,\n      ...settings,\n    },\n  }\n  return state\n}\n\nexport type TanStackDevtoolsConfig = DevtoolsStore['settings']\n\nexport const DevtoolsProvider = (props: ContextProps) => {\n  const [store, setStore] = createStore(\n    getExistingStateFromStorage(props.config, props.plugins),\n  )\n\n  const value = {\n    store,\n    setStore: (\n      updater: (prev: DevtoolsStore) => DevtoolsStore | Partial<DevtoolsStore>,\n    ) => {\n      const newState = updater(store)\n      const { settings, state: internalState } = newState\n      // Store user settings for dev tools into local storage\n      setStorageItem(TANSTACK_DEVTOOLS_SETTINGS, JSON.stringify(settings))\n      // Store general state into local storage\n      setStorageItem(TANSTACK_DEVTOOLS_STATE, JSON.stringify(internalState))\n      setStore((prev) => ({\n        ...prev,\n        ...newState,\n      }))\n    },\n  }\n\n  return (\n    <DevtoolsContext.Provider value={value}>\n      {props.children}\n    </DevtoolsContext.Provider>\n  )\n}\n"],
  "mappings": ";;;;;;;;;;;;AAAO,IAAM,sBAAsB;AAC5B,IAAM,4BAA4B;;;ACDlC,IAAM,iBAAiB,CAAC,QAAgB,aAAa,QAAQ,GAAG;AAChE,IAAM,iBAAiB,CAAC,KAAa,UAAkB;AAC5D,MAAI;AACF,iBAAa,QAAQ,KAAK,KAAK;EACjC,SAAS,IAAI;AACX;EACF;AACF;AAEO,IAAM,oBAAoB;AAC1B,IAAM,0BAA0B;AAChC,IAAM,6BAA6B;;;ACmDnC,IAAM,eAA8B;EACzC,UAAU;IACR,aAAa;IACb,gBAAgB;IAChB,UAAU;IACV,eAAe;IACf,YAAY,CAAC,SAAS,GAAG;IACzB,gBAAgB;IAChB,SAAS;EAAA;EAEX,OAAO;IACL,WAAW;IACX,QAAQ;IACR,cAAc;IACd,aAAa;EAAA;AAEjB;;;AC5EA,IAAM,OAAO,OAAO,WAAW;AAA/B,IACE,QAAQ,OAAO,YAAY;AAD7B,IAEE,OAAO,OAAO,WAAW;AAF3B,IAGE,QAAQ,OAAO,YAAY;AAC7B,IAAM,WAAW;AAAA,EACf,mBAAmB;AACrB;AACA,SAAS,OAAO,OAAO;AACrB,MAAI,IAAI,MAAM,MAAM;AACpB,MAAI,CAAC,GAAG;AACN,WAAO,eAAe,OAAO,QAAQ;AAAA,MACnC,OAAO,IAAI,IAAI,MAAM,OAAO,YAAY;AAAA,IAC1C,CAAC;AACD,QAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACzB,YAAM,OAAO,OAAO,KAAK,KAAK,GAC5B,OAAO,OAAO,0BAA0B,KAAK;AAC/C,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,IAAI,GAAG,KAAK;AAC3C,cAAM,OAAO,KAAK,CAAC;AACnB,YAAI,KAAK,IAAI,EAAE,KAAK;AAClB,iBAAO,eAAe,OAAO,MAAM;AAAA,YACjC,YAAY,KAAK,IAAI,EAAE;AAAA,YACvB,KAAK,KAAK,IAAI,EAAE,IAAI,KAAK,CAAC;AAAA,UAC5B,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AACA,SAAS,YAAY,KAAK;AACxB,MAAI;AACJ,SAAO,OAAO,QAAQ,OAAO,QAAQ,aAAa,IAAI,MAAM,KAAK,EAAE,QAAQ,OAAO,eAAe,GAAG,MAAM,UAAU,OAAO,aAAa,MAAM,QAAQ,GAAG;AAC3J;AACA,SAAS,OAAO,MAAM,MAAM,oBAAI,IAAI,GAAG;AACrC,MAAI,QAAQ,WAAW,GAAG;AAC1B,MAAI,SAAS,QAAQ,QAAQ,KAAK,IAAI,EAAG,QAAO;AAChD,MAAI,CAAC,YAAY,IAAI,KAAK,IAAI,IAAI,IAAI,EAAG,QAAO;AAChD,MAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,QAAI,OAAO,SAAS,IAAI,EAAG,QAAO,KAAK,MAAM,CAAC;AAAA,QAAO,KAAI,IAAI,IAAI;AACjE,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,IAAI,GAAG,KAAK;AAC3C,UAAI,KAAK,CAAC;AACV,WAAK,YAAY,OAAO,GAAG,GAAG,OAAO,EAAG,MAAK,CAAC,IAAI;AAAA,IACpD;AAAA,EACF,OAAO;AACL,QAAI,OAAO,SAAS,IAAI,EAAG,QAAO,OAAO,OAAO,CAAC,GAAG,IAAI;AAAA,QAAO,KAAI,IAAI,IAAI;AAC3E,UAAM,OAAO,OAAO,KAAK,IAAI,GAC3B,OAAO,OAAO,0BAA0B,IAAI;AAC9C,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,IAAI,GAAG,KAAK;AAC3C,aAAO,KAAK,CAAC;AACb,UAAI,KAAK,IAAI,EAAE,IAAK;AACpB,UAAI,KAAK,IAAI;AACb,WAAK,YAAY,OAAO,GAAG,GAAG,OAAO,EAAG,MAAK,IAAI,IAAI;AAAA,IACvD;AAAA,EACF;AACA,SAAO;AACT;AACA,SAAS,SAAS,QAAQ,QAAQ;AAChC,MAAI,QAAQ,OAAO,MAAM;AACzB,MAAI,CAAC,MAAO,QAAO,eAAe,QAAQ,QAAQ;AAAA,IAChD,OAAO,QAAQ,uBAAO,OAAO,IAAI;AAAA,EACnC,CAAC;AACD,SAAO;AACT;AACA,SAAS,QAAQ,OAAO,UAAU,OAAO;AACvC,MAAI,MAAM,QAAQ,EAAG,QAAO,MAAM,QAAQ;AAC1C,QAAM,CAAC,GAAG,GAAG,IAAI,aAAa,OAAO;AAAA,IACnC,QAAQ;AAAA,IACR,UAAU;AAAA,EACZ,CAAC;AACD,IAAE,IAAI;AACN,SAAO,MAAM,QAAQ,IAAI;AAC3B;AACA,SAAS,kBAAkB,QAAQ,UAAU;AAC3C,QAAM,OAAO,QAAQ,yBAAyB,QAAQ,QAAQ;AAC9D,MAAI,CAAC,QAAQ,KAAK,OAAO,CAAC,KAAK,gBAAgB,aAAa,UAAU,aAAa,MAAO,QAAO;AACjG,SAAO,KAAK;AACZ,SAAO,KAAK;AACZ,OAAK,MAAM,MAAM,OAAO,MAAM,EAAE,QAAQ;AACxC,SAAO;AACT;AACA,SAAS,UAAU,QAAQ;AACzB,cAAY,KAAK,QAAQ,SAAS,QAAQ,KAAK,GAAG,KAAK,EAAE;AAC3D;AACA,SAAS,QAAQ,QAAQ;AACvB,YAAU,MAAM;AAChB,SAAO,QAAQ,QAAQ,MAAM;AAC/B;AACA,IAAM,eAAe;AAAA,EACnB,IAAI,QAAQ,UAAU,UAAU;AAC9B,QAAI,aAAa,KAAM,QAAO;AAC9B,QAAI,aAAa,OAAQ,QAAO;AAChC,QAAI,aAAa,QAAQ;AACvB,gBAAU,MAAM;AAChB,aAAO;AAAA,IACT;AACA,UAAM,QAAQ,SAAS,QAAQ,KAAK;AACpC,UAAM,UAAU,MAAM,QAAQ;AAC9B,QAAI,QAAQ,UAAU,QAAQ,IAAI,OAAO,QAAQ;AACjD,QAAI,aAAa,SAAS,aAAa,QAAQ,aAAa,YAAa,QAAO;AAChF,QAAI,CAAC,SAAS;AACZ,YAAM,OAAO,OAAO,yBAAyB,QAAQ,QAAQ;AAC7D,UAAI,YAAY,MAAM,OAAO,UAAU,cAAc,OAAO,eAAe,QAAQ,MAAM,EAAE,QAAQ,KAAK,KAAM,SAAQ,QAAQ,OAAO,UAAU,KAAK,EAAE;AAAA,IACxJ;AACA,WAAO,YAAY,KAAK,IAAI,OAAO,KAAK,IAAI;AAAA,EAC9C;AAAA,EACA,IAAI,QAAQ,UAAU;AACpB,QAAI,aAAa,QAAQ,aAAa,UAAU,aAAa,UAAU,aAAa,SAAS,aAAa,QAAQ,aAAa,YAAa,QAAO;AACnJ,gBAAY,KAAK,QAAQ,SAAS,QAAQ,IAAI,GAAG,QAAQ,EAAE;AAC3D,WAAO,YAAY;AAAA,EACrB;AAAA,EACA,MAAM;AACJ,YAAQ,KAAK,gCAAgC;AAC7C,WAAO;AAAA,EACT;AAAA,EACA,iBAAiB;AACf,YAAQ,KAAK,gCAAgC;AAC7C,WAAO;AAAA,EACT;AAAA,EACA;AAAA,EACA,0BAA0B;AAC5B;AACA,SAAS,YAAY,OAAO,UAAU,OAAO,WAAW,OAAO;AAC7D,MAAI,CAAC,YAAY,MAAM,QAAQ,MAAM,MAAO;AAC5C,QAAM,OAAO,MAAM,QAAQ,GACzB,MAAM,MAAM;AACd,WAAS,qBAAqB,SAAS,kBAAkB,OAAO,UAAU,OAAO,IAAI;AACrF,MAAI,UAAU,QAAW;AACvB,WAAO,MAAM,QAAQ;AACrB,QAAI,MAAM,IAAI,KAAK,MAAM,IAAI,EAAE,QAAQ,KAAK,SAAS,OAAW,OAAM,IAAI,EAAE,QAAQ,EAAE,EAAE;AAAA,EAC1F,OAAO;AACL,UAAM,QAAQ,IAAI;AAClB,QAAI,MAAM,IAAI,KAAK,MAAM,IAAI,EAAE,QAAQ,KAAK,SAAS,OAAW,OAAM,IAAI,EAAE,QAAQ,EAAE,EAAE;AAAA,EAC1F;AACA,MAAI,QAAQ,SAAS,OAAO,KAAK,GAC/B;AACF,MAAI,OAAO,QAAQ,OAAO,UAAU,IAAI,EAAG,MAAK,EAAE,MAAM,KAAK;AAC7D,MAAI,MAAM,QAAQ,KAAK,KAAK,MAAM,WAAW,KAAK;AAChD,aAAS,IAAI,MAAM,QAAQ,IAAI,KAAK,IAAK,EAAC,OAAO,MAAM,CAAC,MAAM,KAAK,EAAE;AACrE,KAAC,OAAO,QAAQ,OAAO,UAAU,GAAG,MAAM,KAAK,EAAE,MAAM,MAAM;AAAA,EAC/D;AACA,GAAC,OAAO,MAAM,KAAK,MAAM,KAAK,EAAE;AAClC;AACA,SAAS,eAAe,OAAO,OAAO;AACpC,QAAM,OAAO,OAAO,KAAK,KAAK;AAC9B,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK,GAAG;AACvC,UAAM,MAAM,KAAK,CAAC;AAClB,gBAAY,OAAO,KAAK,MAAM,GAAG,CAAC;AAAA,EACpC;AACF;AACA,SAAS,YAAY,SAAS,MAAM;AAClC,MAAI,OAAO,SAAS,WAAY,QAAO,KAAK,OAAO;AACnD,SAAO,OAAO,IAAI;AAClB,MAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,QAAI,YAAY,KAAM;AACtB,QAAI,IAAI,GACN,MAAM,KAAK;AACb,WAAO,IAAI,KAAK,KAAK;AACnB,YAAM,QAAQ,KAAK,CAAC;AACpB,UAAI,QAAQ,CAAC,MAAM,MAAO,aAAY,SAAS,GAAG,KAAK;AAAA,IACzD;AACA,gBAAY,SAAS,UAAU,GAAG;AAAA,EACpC,MAAO,gBAAe,SAAS,IAAI;AACrC;AACA,SAAS,WAAW,SAAS,MAAM,YAAY,CAAC,GAAG;AACjD,MAAI,MACF,OAAO;AACT,MAAI,KAAK,SAAS,GAAG;AACnB,WAAO,KAAK,MAAM;AAClB,UAAM,WAAW,OAAO,MACtB,UAAU,MAAM,QAAQ,OAAO;AACjC,QAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,mBAAW,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,IAAI,GAAG,SAAS;AAAA,MACvD;AACA;AAAA,IACF,WAAW,WAAW,aAAa,YAAY;AAC7C,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,YAAI,KAAK,QAAQ,CAAC,GAAG,CAAC,EAAG,YAAW,SAAS,CAAC,CAAC,EAAE,OAAO,IAAI,GAAG,SAAS;AAAA,MAC1E;AACA;AAAA,IACF,WAAW,WAAW,aAAa,UAAU;AAC3C,YAAM;AAAA,QACJ,OAAO;AAAA,QACP,KAAK,QAAQ,SAAS;AAAA,QACtB,KAAK;AAAA,MACP,IAAI;AACJ,eAAS,IAAI,MAAM,KAAK,IAAI,KAAK,IAAI;AACnC,mBAAW,SAAS,CAAC,CAAC,EAAE,OAAO,IAAI,GAAG,SAAS;AAAA,MACjD;AACA;AAAA,IACF,WAAW,KAAK,SAAS,GAAG;AAC1B,iBAAW,QAAQ,IAAI,GAAG,MAAM,CAAC,IAAI,EAAE,OAAO,SAAS,CAAC;AACxD;AAAA,IACF;AACA,WAAO,QAAQ,IAAI;AACnB,gBAAY,CAAC,IAAI,EAAE,OAAO,SAAS;AAAA,EACrC;AACA,MAAI,QAAQ,KAAK,CAAC;AAClB,MAAI,OAAO,UAAU,YAAY;AAC/B,YAAQ,MAAM,MAAM,SAAS;AAC7B,QAAI,UAAU,KAAM;AAAA,EACtB;AACA,MAAI,SAAS,UAAa,SAAS,OAAW;AAC9C,UAAQ,OAAO,KAAK;AACpB,MAAI,SAAS,UAAa,YAAY,IAAI,KAAK,YAAY,KAAK,KAAK,CAAC,MAAM,QAAQ,KAAK,GAAG;AAC1F,mBAAe,MAAM,KAAK;AAAA,EAC5B,MAAO,aAAY,SAAS,MAAM,KAAK;AACzC;AACA,SAAS,eAAe,CAAC,OAAO,OAAO,GAAG;AACxC,QAAM,iBAAiB,OAAO,SAAS,CAAC,CAAC;AACzC,QAAM,UAAU,MAAM,QAAQ,cAAc;AAC5C,MAAI,OAAO,mBAAmB,YAAY,OAAO,mBAAmB,WAAY,OAAM,IAAI,MAAM,mBAAmB,OAAO,cAAc,gEAAgE;AACxM,QAAM,eAAe,OAAO,cAAc;AAC1C,MAAM,cAAc;AAAA,IAClB,OAAO;AAAA,IACP,MAAM,WAAW,QAAQ;AAAA,EAC3B,CAAC;AACD,WAAS,YAAY,MAAM;AACzB,UAAM,MAAM;AACV,iBAAW,KAAK,WAAW,IAAI,YAAY,gBAAgB,KAAK,CAAC,CAAC,IAAI,WAAW,gBAAgB,IAAI;AAAA,IACvG,CAAC;AAAA,EACH;AACA,SAAO,CAAC,cAAc,QAAQ;AAChC;AAuGA,IAAM,QAAQ,OAAO,YAAY;;;ACxU1B,IAAM,eAAe,CAAI,SAAuC;AACrE,MAAI,CAAC,KAAM,QAAO;AAClB,MAAI;AACF,WAAO,KAAK,MAAM,IAAI;EACxB,SAAS,IAAI;AACX,WAAO;EACT;AACF;AAEO,IAAM,uBAAuB,CAAC,UACnC,MAAM,OAAO,CAAC,EAAE,YAAA,IAAgB,MAAM,MAAM,CAAC;;;ACmDxC,IAAMA,kBAAkBC,cAAAA;AAW/B,IAAMC,cAAcA,MAAM;AACxB,QAAMC,iBAAiBC,eAAeC,0BAA0B;AAChE,QAAMC,WAAWC,aAAwCJ,cAAc;AACvE,SAAO;IACL,GAAGG;EAAAA;AAEP;AAEA,IAAME,mBAAmBA,CAACC,QAAgCC,UAAkB;AAE1E,MAAID,OAAOE,IAAI;AACb,WAAOF,OAAOE;EAChB;AACA,MAAI,OAAOF,OAAOG,SAAS,UAAU;AAEnC,WAAOH,OAAOG,KAAKC,YAAAA,EAAcC,QAAQ,KAAK,GAAG;EACnD;AAEA,SAAOJ,MAAMK,SAAAA;AACf;AAEA,IAAMC,8BAA8BA,CAClCC,QACAC,YACG;AACH,QAAMC,gBAAgBf,eAAegB,uBAAuB;AAC5D,QAAMd,WAAWJ,YAAAA;AAEjB,QAAMmB,QAAuB;IAC3B,GAAGC;IACHJ,UACEA,mCAASK,IAAI,CAACd,QAAQe,MAAM;AAC1B,YAAMb,KAAKH,iBAAiBC,QAAQe,CAAC;AACrC,aAAO;QACL,GAAGf;QACHE;MAAAA;IAEJ,OAAM,CAAA;IACRU,OAAO;MACL,GAAGC,aAAaD;MAChB,GAAIF,gBAAgBM,KAAKC,MAAMP,aAAa,IAAI,CAAA;IAAC;IAEnDb,UAAU;MACR,GAAGgB,aAAahB;MAChB,GAAGW;MACH,GAAGX;IAAAA;EACL;AAEF,SAAOe;AACT;AAIO,IAAMM,mBAAmBA,CAACC,UAAwB;AACvD,QAAM,CAACC,OAAOC,QAAQ,IAAIC,YACxBf,4BAA4BY,MAAMX,QAAQW,MAAMV,OAAO,CACzD;AAEA,QAAMc,QAAQ;IACZH;IACAC,UAAUA,CACRG,YACG;AACH,YAAMC,WAAWD,QAAQJ,KAAK;AAC9B,YAAM;QAAEvB;QAAUe,OAAOc;MAAAA,IAAkBD;AAE3CE,qBAAe/B,4BAA4BoB,KAAKY,UAAU/B,QAAQ,CAAC;AAEnE8B,qBAAehB,yBAAyBK,KAAKY,UAAUF,aAAa,CAAC;AACrEL,eAAUQ,CAAAA,UAAU;QAClB,GAAGA;QACH,GAAGJ;MAAAA,EACH;IACJ;EAAA;AAGF,SAAAK,gBACGvC,gBAAgBwC,UAAQ;IAACR;IAAY,IAAAS,WAAA;AAAA,aACnCb,MAAMa;IAAQ;EAAA,CAAA;AAGrB;",
  "names": ["DevtoolsContext", "createContext", "getSettings", "settingsString", "getStorageItem", "TANSTACK_DEVTOOLS_SETTINGS", "settings", "tryParseJson", "generatePluginId", "plugin", "index", "id", "name", "toLowerCase", "replace", "toString", "getExistingStateFromStorage", "config", "plugins", "existingState", "TANSTACK_DEVTOOLS_STATE", "state", "initialState", "map", "i", "JSON", "parse", "DevtoolsProvider", "props", "store", "setStore", "createStore", "value", "updater", "newState", "internalState", "setStorageItem", "stringify", "prev", "_$createComponent", "Provider", "children"]
}
